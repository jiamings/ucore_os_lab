## Lab 2

### 练习0

使用meld填写。

### 练习1

根据注释和已经给出的代码，发现只需要在原来流程的基础上修改几个地方。重点是了解内存块分配的流程。

**初始化时** 这时所有块都是空闲的一个大块。比如说这个有四个块的内存：

| Block #  | 1        | 2        | 3        | 4        |
| -------- | -------- | -------- | -------- | -------- |
| Property | 4        | 0        | 0        | 0        |
| Next     | 2        | 3        | 4        | 1        |
| Prev     | 4        | 1        | 2        | 3        |
| Flags    | Property | Property | Property | Property |

**分配一个3的内存** 这时找到1的Property = 4 > 3 所以用来分配。

| Block #  | 1        | 2        | 3        | 4        |
| -------- | -------- | -------- | -------- | -------- |
| Property | 0        | 0        | 0        | 1        |
| Next     | -        | -        | -        | 4        |
| Prev     | -        | -        | -        | 4        |
| Flags    | Reserved | Reserved | Reserved | Property |

**释放内存块** 释放内存除了要将本身对应的内存加入链表，还需要考虑两种情况

1. 释放出的内存和后面的内存相连
2. 释放出的内存和前面的内存相连

在这两个情况下，要分别处理，将前面的Property设置为连续内存大小的总和，将中间的Property设置为0，如下:

| Before   | p    | q    | After    | p    | q    |
| -------- | ---- | ---- | -------- | ---- | ---- |
| Property | 1    | 10   | Property | 11   | 0    |

**本实现和答案实现的不同** 本实现中，使用了原始代码中所提供的框架，其中各个位置的意义用注释体现。其中最重要的区别是free内存中的不同：我的实现中，寻找两种特殊情况是采用while循环查找整个内存，这样在内存空间大，页数多的情况下效率较低。而答案的方法直接在释放内存基址附近进行查找，避免了while循环的时间开销。

**改进方法** 可以在记录最大内存块的同时，维护最大内存块所制定的地址，这样就不需要在分配内存的时候，临时查找分配的内存了。



### 练习2

根据注释中的提示，我们按照每一步写下代码。其中我的实现和答案差距不大，都是基于注释实现的。这里需要注意(pte_t *)和(pde_t *)的转换。

**页目录项和页表项的含义** 根据[这里](https://objectkuan.gitbooks.io/ucore-docs/content/lab2/lab2_3_3_5_1_segment_and_paging.html)，页目录项(PDE)和页表项(PTE)构成了访问页表的二级实现，其中PTE提供了对物理地址(PA)基址的映射；PDE相当于PTE的页表，它们的关系和PTE对PA的关系蕾丝，因此被称为二级页表。

![](https://objectkuan.gitbooks.io/ucore-docs/content/lab2_figs/image006.png)

**对ucore的用处** 为什么要使用二级页表而不是一级页表呢？这里一个明显的好处是节省了页表所需要的空间：一级页表需要$2^{20}$个表项，而二级页表只需要$2^{10} + X$个表项（这里$X$指二级页表的大小），由于程序执行和内存访问的局部性，二级页表替换的频率不会很高，效率不会受到过多影响，可以说是用一小部分时间换取了大量空间。

​	

### 练习3

和练习二类似，这里按照注释一步一步写就可以了。唯一的区别是我并没有使用page\_ref\_dec 中的函数返回值，而是直接用了page->ref。

**全局变量** Page的全局变量在pmm.c中为struct Page *pages; 其中注释表示了这个数组的含义是所在物理地址页对应的虚拟地址。由于虚拟地址对应了页目录项和页表项，因此有对应关系。

**虚拟地址和物理地址映射** 注意到KADDR宏定义中，virtual_address = physical_address + KERNBASE,  其中KERNBASE = 0xC0000000，和[这里](https://objectkuan.gitbooks.io/ucore-docs/content/lab2/lab2_3_3_5_4_maping_relations.html)的说明是一样的。因此想要虚拟地址和物理地址一样，修改KERNBASE变量的值就可以了。

