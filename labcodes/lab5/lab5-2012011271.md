## Lab 5

### Exercise 0

需要注意的是，为了能够顺利测试，需要将kern/trap/trap.c中每个TICK_NUM周期输出的tick信息去掉。否则就会因为assert导致系统运行中断。

由于增加了用户态，在进行syscall的时候也要增加相应的设置。

proc.c中的do_fork函数需要添加set_links步骤，并将原先的一些累加操作去掉。

### Exercise 1

练习1要求在load_icode中添加trapframe的设置。

只要按照注释的指引就可以实现了。需要注意的是，对于eflags而言，FL_LF表示中断。

**用户台加载程序是如何执行的** 本次实验中，用户进程由 initproc 进程将用户的应用程序的执行代码复制到 initproc 进程的用户虚存代码空间。在用户进程的程序运行环境在栈中填充完成之后，initproc 会利用 iret 的方法，将指令指针指向用户程序的第一条语句开始执行。

### Exercise 2

只需要将page页中的数据拷贝到npage页中的数据，并将npage插入到map中完成物理地址与线性地址的映射即可。

具体的实现如下代码所示。 

**简要说明如何实现Copy on Write** 为了实现这个机制，在父进程创建子进程的时候，并不复制存储空间，而是单纯将虚存指针复制给了子进程并设置成只读模式，防止子进程对其进行修改。

当父进程或者子进程对这块空间进行写操作的时候，会产生一个异常。通过分析这个异常可以发现它尝试写了一个只读块。由此可以知道，这个块需要被复制，之后才可以进行写操作。
1. 当虚存需要被复制的时候，并不直接讲vma复制到nvma中，而是直接复制了vma的指针，并设置这块虚拟内存空间的权限为只读。
2. 当某一个空间的使用者尝试对这个空间进行写入的时候，会产生异常，这时候就交由vmm.c中的 do_pgfault 来处理。
3.  发现异常是由于对只读空间进行写产生的，因此会新建一个新的nvma，并将原先的vma中的数据进行复制，和设置权限为可写。
4. 此时写入操作就可以继续进行了，Copy on Write机制就对进程是不可见的了。

### Exercise 3

fork：创建子线程，为线程准备数据，并将新的线程唤醒

exec：令进程加载一个二进制程序，并执行

wait：对于一个正在运行的进程，将进程的状态设置为 PROC_SLEEPING

exit：释放进程的大部分资源，设置进程的状态为 PROC_ZOMBIE ，并将其子进程的父进程设置成内核进程，等待父进程对这个进程和已经在 PROC_ZOMBIE 状态中的子进程进行最后的回收工作。

```
alloc_proc
     |
     |
     v
[PROC_UNINIT]
     |
     |
     v
 proc_init -+-> [PROC_RUNNABLE] -+-> fork ---> wait ---> exit
            |                    |    |
            +----- proc_run -----+    |
                                      |
            +-> [PROC_RUNNABLE] -+----+
            |                    |
            +----- proc_run -----+----> exit ----> [PROC_ZOMBIE] 
```

