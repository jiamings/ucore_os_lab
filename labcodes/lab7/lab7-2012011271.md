## Lab 7

### Exercise 0

在完成练习0的过程中，需要为时钟中断修改代码，将之前全部的在时钟中断触发的函数修改为一个`run_timer_list();`。

```
case IRQ_OFFSET + IRQ_TIMER:
    run_timer_list();
    break;
```


### Exercise 1

#### 内核级信号量的设计描述和执行流程

在ucore中，内核级的信号量用semaphore_t来表示。value用来表示该信号量可用的资源总数。

当value值小于等于0，所有对这个信号量申请资源的操作都会通过schedule()被阻塞等待，并加入到等待队列中。

当一个新的信号量可用的时候，就找到一个进程使它继续执行。

在ucore中，信号量有四个基本的操作：

- sema_init 初始化信号量
- up 信号量的V操作
- down 信号量的P操作
- try_down 如果有资源，分配一个

为了保证内核级信号量正常工作，除了sema_init操作之外的所有操作都需要在内核中断保护的情况下，防止被其他的中断所中断，导致运行异常。

#### 用户态信号量机制的设计方案

事实上，由于用户态没有办法关闭中断，没有纯粹在用户态中的原子操作。在用户态中实现信号量机制，仍然需要在内核态中进行系统调用。(semget(), semop(), semctl() )

### Exercise 2

#### 内核态条件变量的设计描述和代码实现

根据monitor.c中的注释，以及实验书上的信息可以填写大部分的信息。

cond_signal中，要将一个条件变量设置成可用。

cond_wait中，进程想要主动放弃运行，并等待条件出现。其中可以唤醒进程或者释放互斥锁。

#### 哲学家就餐问题实现

见check_sync.c。

当一个哲学家想要拿起叉子的时候，这个哲学家的状态需要设置为“等待叉子”，并且判断是不是可以拿起叉子。

当一个哲学家放下叉子的时候，需要检查并通知左右的哲学家，询问他们是不是在进食。

用户态条件变量机制实现依然是通过内核级条件变量机制来间接实现。

